# Generated by [Mush Audit](https://mush-audit.vercel.app/)

## About

ENA 合约是一个治理代币合约，用于 Ethena 协议。它继承了 `Ownable2Step`, `ERC20Burnable`, 和 `ERC20Permit` 功能，并定义了最大年化通胀率 (`MAX_INFLATION`) 和最小铸币间隔 (`MINT_WAIT_PERIOD`)。该合约允许拥有者在满足时间间隔限制和通胀率限制的情况下铸造新的代币。合约在部署时，会将初始代币分配给 `_treasury` 和 `_foundation` 地址。此外，合约阻止拥有者放弃所有权。

## Findings Severity breakdown
- Critical: 0
- High: 0
- Medium: 1
- Low: 1
- Gas: 2

### Mint Timestamp Manipulation
- **Title:** Mint Timestamp Manipulation
- **Severity:** Medium
- **Description:** 合约使用 `uint40` 来存储 `lastMintTimestamp`。尽管 `block.timestamp` 返回一个 `uint256` 值，但在这种情况下，由于 `MINT_WAIT_PERIOD` 的限制，`uint40` 的范围足以应对。然而，在理论上，如果 `block.timestamp` 在极长一段时间后增加到大于 `uint40` 的最大值（2^40 - 1），则可能会发生数据溢出，并且铸币间隔检查 (`block.timestamp - lastMintTimestamp < MINT_WAIT_PERIOD`) 将失效。虽然这种情况在实际中极不可能发生（因为 `uint40` 的上限足够大，远大于实际区块链可能运行的时间），但从安全角度来看，这种潜在的风险应被标记。
- **Impact:** 如果 `block.timestamp` 溢出 `uint40` 的最大值，铸币间隔检查可能会被绕过，允许合约所有者在一年内多次铸造代币，从而可能造成通货膨胀。
- **Location:** ENA.sol:14, ENA.sol:30
- **Recommendation:** 尽管实际风险极低，但为了确保合约的健壮性和避免潜在的未预期行为，建议使用 `uint256` 而不是 `uint40` 来存储 `lastMintTimestamp`。虽然这将消耗少量额外gas，但是可以杜绝潜在的溢出风险。

---

### Unnecessary `view` modifier on `renounceOwnership` Function
- **Title:** Unnecessary `view` modifier on `renounceOwnership` Function
- **Severity:** Low
- **Description:** `renounceOwnership` 函数被标记为 `view`，尽管它在合约中通过 `revert` 关键字抛出异常，表明该操作并没有修改合约状态。`view` 函数不应该有状态修改的指令。
- **Impact:** 该 `view` 修饰符是多余的，并未影响合约的安全性，但是这可能混淆代码，导致开发者误认为该函数确实不修改状态。
- **Location:** ENA.sol:34
- **Recommendation:** 删除 `view` 修饰符，并保持函数为 `public`，因为该函数会 `revert`。

---

###  Potential Gas Optimization: Using `unchecked` block for Arithmetic Operation
- **Title:** Potential Gas Optimization: Using `unchecked` block for Arithmetic Operation
- **Severity:** Gas
- **Description:** 在 `mint` 函数中， `uint256 _maxInflationAmount = totalSupply() * MAX_INFLATION / 100;`  的算术运算在 Solidity 0.8.x 中默认会进行溢出检查。由于 `MAX_INFLATION` 是一个 `uint8`，且已知最大值为 10，并且在合约的上下文中，`totalSupply()` 乘以 10 再除以 100，因此该算术运算不可能溢出，所以可以使用 `unchecked` 块来减少 Gas 消耗。
- **Impact:** 通过使用 `unchecked` 块，可以稍微减少 Gas 消耗。
- **Location:** ENA.sol:29
- **Recommendation:** 将算术运算包裹在 `unchecked` 块中。 `unchecked { uint256 _maxInflationAmount = totalSupply() * MAX_INFLATION / 100; }`

---

### Gas Optimization : Using constant for initial Supply

- **Title:** Gas Optimization : Using constant for initial Supply
- **Severity:** Gas
- **Description:** 在构造函数中，初始供应量的计算 `3_750_000_000 * 10 ** 18` 和 `11_250_000_000 * 10 ** 18` 会在每次合约部署时重新计算。 将这些值定义为 `constant` 可以节省部署 Gas。
- **Impact:** 通过使用 `constant`，可以稍微减少部署 Gas 消耗。
- **Location:** ENA.sol:20, ENA.sol:21
- **Recommendation:** 定义两个新的 constant 变量，并使用在合约的构造函数中。

## Detailed Analysis

### Architecture

ENA 合约是一个治理代币合约，其核心功能是铸造和燃烧代币。它继承了 ERC20 标准接口，允许代币的转移、批准和燃烧。合约拥有一个 `mint` 方法，只能由所有者调用，用于创建新的代币，并受制于时间和最大通胀率的限制。此外，它使用 `Ownable2Step` 来管理所有权，并阻止所有者放弃所有权。

### Code Quality

代码整体质量良好，使用了清晰的命名和注释，便于理解合约逻辑。但是，如前所述，`lastMintTimestamp` 的数据类型以及 `renounceOwnership` 函数的 `view` 修饰符和 `mint` 函数中算术运算有优化空间。

### Centralization Risks

合约的所有者可以铸造新的代币，因此是一个中心化控制点。所有者有权在满足时间和通胀率限制的情况下，铸造新的代币到任何地址。虽然有 `MINT_WAIT_PERIOD` 和 `MAX_INFLATION` 的限制，但如果所有者滥用 `mint` 方法，依然会对代币经济产生负面影响。但是，合同限制了所有者放弃所有权的操作。

### Systemic Risks

合约依赖于以太坊区块链的 `block.timestamp`。虽然 `block.timestamp` 存在被矿工操纵的风险，但这种操纵通常仅在短时间内，且会影响整个区块链，而不仅仅是该合约。合约的业务逻辑主要依赖于 `ERC20` 标准，这部分代码是经过广泛测试和审查的，比较安全。

### Testing & Verification

为了确保合约的安全和正确性，需要进行全面的单元测试。特别是要测试 `mint` 方法的边界情况：
* 验证能否在 `MINT_WAIT_PERIOD` 之后成功铸造代币。
* 验证是否在 `MINT_WAIT_PERIOD` 之前铸造代币会失败。
* 验证铸造超过 `MAX_INFLATION` 的代币会失败。
* 验证铸造小于等于 `MAX_INFLATION` 的代币会成功。
* 验证首次部署时，代币的分配是否正确。
* 验证 `renounceOwnership` 方法是否确实会 `revert`。

## Final Recommendations

1. **使用 `uint256` 存储 `lastMintTimestamp`:** 尽管风险极低，但将 `lastMintTimestamp` 的数据类型从 `uint40` 改为 `uint256` 可以完全消除潜在的溢出风险。
2. **删除 `renounceOwnership` 函数的 `view` 修饰符:** 移除不必要的 `view` 修饰符，保持代码的简洁和正确性。
3. **使用 `unchecked` 块优化算术运算:** 在 `mint` 函数中使用 `unchecked` 块来优化 gas 消耗。
4. **使用 `constant` 优化初始供应量:** 将初始供应量定义为常量，可以减少部署 Gas。
5.  **增加全面的单元测试:** 添加更全面的单元测试，以覆盖各种情况，特别是 `mint` 函数的边界条件。

## Improved Code with Security Comments

```solidity
// File: ENA.sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.20;

import "@openzeppelin/contracts/access/Ownable2Step.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol";

interface IENADefinitions {
  error MintWaitPeriodInProgress();
  error MaxInflationExceeded();
  error ZeroAddressException();
  error CantRenounceOwnership();
  event Mint(address indexed to, uint256 amount);
}

/**
 * @title ENA
 * @notice Governance token for the Ethena protocol
 */
contract ENA is Ownable2Step, ERC20Burnable, ERC20Permit, IENADefinitions {
  /// @notice Maximum inflation rate per year (percentage) expressed as an integer
  uint8 public constant MAX_INFLATION = 10;

  /// @notice The maximum frequency of inflationary mint invocations
  uint32 public constant MINT_WAIT_PERIOD = 365 days;

   /// @notice Initial supply for treasury
    uint256 public constant INITIAL_TREASURY_SUPPLY = 3_750_000_000 * 10 ** 18;
    /// @notice Initial supply for foundation
    uint256 public constant INITIAL_FOUNDATION_SUPPLY = 11_250_000_000 * 10 ** 18;

  /// @notice The last time the mint function was called
  uint256 public lastMintTimestamp; // Changed to uint256 to prevent potential overflow

  constructor(address _initialOwner, address _treasury, address _foundation) ERC20("ENA", "ENA") ERC20Permit("ENA") {
    // first mint not allowed until 1 year after deployment
    lastMintTimestamp = block.timestamp;
    if (_initialOwner == address(0) || _treasury == address(0) || _foundation == address(0)) revert ZeroAddressException();
    _transferOwnership(_initialOwner);
    // initial supply of 15 billion tokens
    _mint(_treasury, INITIAL_TREASURY_SUPPLY); // Use constant for initial supply
    _mint(_foundation, INITIAL_FOUNDATION_SUPPLY); // Use constant for initial supply
  }

  /**
   * @notice Mints new ENA tokens
   * @param to The address to mint tokens to
   * @param amount The amount of tokens to mint
   * @dev Only callable by the owner once per year and amount must be less than max inflation rate
   */
  function mint(address to, uint256 amount) external onlyOwner {
    if (block.timestamp - lastMintTimestamp < MINT_WAIT_PERIOD) revert MintWaitPeriodInProgress();
    uint256 _maxInflationAmount;
     unchecked { // Use unchecked block for gas optimization as no overflow is expected
        _maxInflationAmount = totalSupply() * MAX_INFLATION / 100;
     }
    if (amount > _maxInflationAmount) revert MaxInflationExceeded();
    lastMintTimestamp = block.timestamp;
    _mint(to, amount);
    emit Mint(to, amount);
  }

  /// @notice Prevents the owner from renouncing ownership
  function renounceOwnership() public override onlyOwner { // Removed view modifier
    revert CantRenounceOwnership();
  }
}
```
