# Generated by [Mush Audit](https://mush-audit.vercel.app/)

## About

The ENA contract is a governance token for the Ethena protocol. It inherits functionalities from `Ownable2Step`, `ERC20Burnable`, and `ERC20Permit`. It defines a maximum annual inflation rate (`MAX_INFLATION`) and a minimum minting interval (`MINT_WAIT_PERIOD`). The contract allows the owner to mint new tokens subject to these limitations.  Initial token supply is allocated to a treasury and foundation addresses upon deployment. The contract also prevents the owner from renouncing ownership.

## Findings Severity breakdown
- Critical: 0
- High: 0
- Medium: 1
- Low: 1
- Gas: 2

### Mint Timestamp Manipulation
- **Title:** Mint Timestamp Manipulation
- **Severity:** Medium
- **Description:** The contract stores the last mint timestamp using a `uint40` (`lastMintTimestamp`). While `block.timestamp` returns a `uint256`, the current implementation appears to work because `MINT_WAIT_PERIOD` ensures minting frequency is yearly, however, in a theoretical scenario, if `block.timestamp` increases to a value greater than the maximum value of `uint40` (2^40 - 1) after an extremely long period, a data overflow could occur. This overflow would cause the minting interval check (`block.timestamp - lastMintTimestamp < MINT_WAIT_PERIOD`) to fail, and minting could be allowed before the year has passed. While this is highly improbable due to the practical limitations of blockchain lifetime, it's a potential vulnerability to be aware of.
- **Impact:** If `block.timestamp` overflows `uint40`, the mint interval check could be bypassed, allowing the contract owner to mint tokens multiple times within a year, potentially leading to inflation.
- **Location:** ENA.sol:14, ENA.sol:30
- **Recommendation:** Change the data type of `lastMintTimestamp` from `uint40` to `uint256`. Although this will consume slightly more gas for storage, it eliminates any risk of overflow and ensures the minting interval logic works as intended under all circumstances.

---

### Unnecessary `view` modifier on `renounceOwnership` Function
- **Title:** Unnecessary `view` modifier on `renounceOwnership` Function
- **Severity:** Low
- **Description:**  The `renounceOwnership` function is marked as `view`, although it always reverts the transaction using `revert CantRenounceOwnership()`. A `view` function cannot modify the contract state, and by definition, throwing a `revert` isn't modifying the contract state, however a revert implies a state-change attempt, which makes view modifiers confusing in this context.
- **Impact:** The `view` modifier is unnecessary and might confuse developers into thinking that the function doesn't attempt state changes. It's a code quality issue, not a security flaw.
- **Location:** ENA.sol:34
- **Recommendation:** Remove the `view` modifier from the `renounceOwnership` function. It should remain a `public` function that `reverts`.

---

### Potential Gas Optimization: Using `unchecked` block for Arithmetic Operation
- **Title:** Potential Gas Optimization: Using `unchecked` block for Arithmetic Operation
- **Severity:** Gas
- **Description:** In the `mint` function, the line `uint256 _maxInflationAmount = totalSupply() * MAX_INFLATION / 100;` performs an arithmetic operation where `MAX_INFLATION` is a `uint8` constant with a maximum value of 10. This calculation is part of a yearly inflation control mechanism. Since the maximum inflation is only 10%, no overflow will occur because `totalSupply` multiplied by 10 and then divided by 100 will not exceed the maximum `uint256` value, and no overflow is possible. Therefore, it is safe to use an `unchecked` block to disable overflow checking.
- **Impact:** Using an `unchecked` block will save a small amount of gas, especially on frequently called functions.
- **Location:** ENA.sol:29
- **Recommendation:** Enclose the arithmetic operation within an `unchecked` block: `unchecked { _maxInflationAmount = totalSupply() * MAX_INFLATION / 100; }`. This will disable the overflow check and slightly reduce gas consumption.

---

### Gas Optimization : Using constant for initial Supply

- **Title:** Gas Optimization : Using constant for initial Supply
- **Severity:** Gas
- **Description:**  In the constructor, the initial supply allocations `3_750_000_000 * 10 ** 18` and `11_250_000_000 * 10 ** 18` are calculated each time the contract is deployed. Defining these values as `constant` variables will avoid these computations during deployment, thus saving gas.
- **Impact:** By using constants, the contract will consume less gas during deployment.
- **Location:** ENA.sol:20, ENA.sol:21
- **Recommendation:** Define `INITIAL_TREASURY_SUPPLY` and `INITIAL_FOUNDATION_SUPPLY` as `constant` variables and use them in the constructor for initial minting.

## Detailed Analysis

### Architecture

The ENA contract is a governance token contract designed around the ERC20 standard. It inherits the basic token functionalities of `ERC20`, `ERC20Burnable`, and `ERC20Permit` and is designed to be managed by a centralized owner using `Ownable2Step`. Its core functionality is the `mint` function, which allows the owner to inflate the token supply under specific time and inflation rate constraints. It uses `block.timestamp` to manage time and has no external interactions, which limits its exposure to external dependencies.

### Code Quality

The code is generally well-written, using clear names and comments for readability. The contract has clear documentation using NatSpec comments. The current version has minor code quality issues around the use of `uint40` for `lastMintTimestamp`, the `view` modifier on the `renounceOwnership` function, and inefficient calculations of initial supply amounts. There are minor gas optimizations that can be performed in the contract as described above.

### Centralization Risks

The contract is heavily centralized. The owner (address that inherits `Ownable2Step`) has the sole authority to mint new tokens through the `mint` function, which has implications on the token economics. Although there is a yearly minting restriction via `MINT_WAIT_PERIOD` and an annual inflation cap using `MAX_INFLATION`, abuse of the `mint` function could significantly impact the token supply. The contract, however, limits the owner's ability to renounce ownership, further reinforcing its centralized design.

### Systemic Risks

The contract depends on `block.timestamp` for its minting timing mechanism. While block timestamps can be manipulated by miners, such manipulations are limited to short-term durations and would affect the entire blockchain and not just this contract. There is no external interaction risks as all token minting is done internally based on time and inflation rate constraints. The core token transfer logic relies on the battle-tested `ERC20` standard, mitigating risks associated with token transfer.

### Testing & Verification

The contract requires rigorous testing to ensure proper functionality. Specifically, testing should include:
*   Verification that minting is allowed only after `MINT_WAIT_PERIOD` has passed.
*   Verification that minting attempts before `MINT_WAIT_PERIOD` fail.
*   Verification that minting exceeds `MAX_INFLATION` fails.
*   Verification that minting less than or equal to `MAX_INFLATION` succeeds.
*   Verification that the correct amounts of tokens are distributed to the treasury and foundation addresses during deployment.
*   Verification that `renounceOwnership` function always reverts as intended.

## Final Recommendations

1.  **Change `lastMintTimestamp` to `uint256`:** Use `uint256` instead of `uint40` for `lastMintTimestamp` to avoid potential overflow issues, ensuring minting restrictions work under all circumstances.
2.  **Remove `view` modifier from `renounceOwnership`:**  Remove the unnecessary `view` modifier from the `renounceOwnership` function as it always reverts and does not modify contract state.
3.  **Use `unchecked` block for arithmetic:**  Use an `unchecked` block for the arithmetic operation in the `mint` function to optimize gas consumption because there is no potential overflow risk.
4. **Use `constant` for initial supply:** Define constants for initial treasury and foundation supplies to save gas during contract deployment.
5.  **Implement Comprehensive Unit Tests:**  Add more comprehensive unit tests to cover various scenarios, particularly the `mint` function's boundary conditions and deployment verification.

## Improved Code with Security Comments

```solidity
// File: ENA.sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.20;
interface IENADefinitions {
  error MintWaitPeriodInProgress();
  error MaxInflationExceeded();
  error ZeroAddressException();
  error CantRenounceOwnership();
  event Mint(address indexed to, uint256 amount);
}

/**
 * @title ENA
 * @notice Governance token for the Ethena protocol
 */
contract ENA is Ownable2Step, ERC20Burnable, ERC20Permit, IENADefinitions {
  /// @notice Maximum inflation rate per year (percentage) expressed as an integer
  uint8 public constant MAX_INFLATION = 10;

  /// @notice The maximum frequency of inflationary mint invocations
  uint32 public constant MINT_WAIT_PERIOD = 365 days;

  /// @notice Initial supply for treasury
  uint256 public constant INITIAL_TREASURY_SUPPLY = 3_750_000_000 * 10 ** 18;
  /// @notice Initial supply for foundation
  uint256 public constant INITIAL_FOUNDATION_SUPPLY = 11_250_000_000 * 10 ** 18;

  /// @notice The last time the mint function was called
  uint256 public lastMintTimestamp; // Changed to uint256 to prevent potential overflow

  constructor(address _initialOwner, address _treasury, address _foundation) ERC20("ENA", "ENA") ERC20Permit("ENA") {
    // first mint not allowed until 1 year after deployment
    lastMintTimestamp = block.timestamp;
    if (_initialOwner == address(0) || _treasury == address(0) || _foundation == address(0)) revert ZeroAddressException();
    _transferOwnership(_initialOwner);
    // initial supply of 15 billion tokens
    _mint(_treasury, INITIAL_TREASURY_SUPPLY); // Use constant for initial supply
    _mint(_foundation, INITIAL_FOUNDATION_SUPPLY); // Use constant for initial supply
  }

  /**
   * @notice Mints new ENA tokens
   * @param to The address to mint tokens to
   * @param amount The amount of tokens to mint
   * @dev Only callable by the owner once per year and amount must be less than max inflation rate
   */
  function mint(address to, uint256 amount) external onlyOwner {
    if (block.timestamp - lastMintTimestamp < MINT_WAIT_PERIOD) revert MintWaitPeriodInProgress();
    uint256 _maxInflationAmount;
     unchecked { // Use unchecked block for gas optimization as no overflow is expected
        _maxInflationAmount = totalSupply() * MAX_INFLATION / 100;
     }
    if (amount > _maxInflationAmount) revert MaxInflationExceeded();
    lastMintTimestamp = block.timestamp;
    _mint(to, amount);
    emit Mint(to, amount);
  }

  /// @notice Prevents the owner from renouncing ownership
  function renounceOwnership() public override onlyOwner { // Removed view modifier
    revert CantRenounceOwnership();
  }
}
```
